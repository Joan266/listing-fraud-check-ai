import uuid
import enum
from sqlalchemy import Column, String, JSON, Enum as SQLAlchemyEnum, func, text
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from .session import Base

class JobStatus(enum.Enum):
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"

class FraudCheck(Base):
    __tablename__ = "fraud_checks"

    # Use the standard UUID type for the primary key.
    # The 'server_default' with text() is a robust way to generate UUIDs at the DB level.
    id = Column(PG_UUID(as_uuid=True), primary_key=True, server_default=text("gen_random_uuid()"))

    # A unique hash of the initial input_data to prevent duplicate runs.
    # The index=True makes lookups for existing hashes very fast.
    input_hash = Column(String(64), nullable=False, unique=True, index=True)

    # The current status of the analysis job.
    status = Column(SQLAlchemyEnum(JobStatus), nullable=False, default=JobStatus.PENDING)

    # The original, structured JSON data that initiated the analysis.
    input_data = Column(JSON, nullable=False)

    # The final, consolidated report generated by the last aggregation job.
    final_report = Column(JSON, nullable=True)

    # Timestamps for tracking and auditing.
    created_at = Column(JSON, server_default=func.now())
    updated_at = Column(JSON, server_default=func.now(), onupdate=func.now())